#ifndef SERVER_H
#define SERVER_H

#include <string>
#include <unordered_map>
#include <vector>
#include <chrono>
#include <pthread.h>

#include "Constants.h"
#include "Crypto.h"
#include "Transaction.h"

struct Session
{
    std::vector<unsigned char> hmac_key;
    std::vector<unsigned char> aes_key;
    std::string user;
    std::chrono::system_clock::time_point last_ping;
};

class Server {
public:
    /**
     * @brief Default constructor for the Server class
     * Initializes session mutex and reads server certificate
     */
    Server();

    /**
     * @brief Destructor for the Server class
     * Destroys session keys, frees server certificate, closes the server socket, and destroys the session mutex
     */
    ~Server();

    /**
     * @brief Destroys session keys
     * @param session Reference to the session object whose keys need to be destroyed
     */
    void destroy_session_keys(Session &session);

    /**
     * @brief wrapper for the check_expired_sessions
     * @param arg
     * @return nullptr
     */
    static void* check_expired_sessions_wrapper(void* arg);

    /**
     * @brief Checks for and handles expired sessions
     */
    void check_expired_sessions();

    /**
     * @brief Starts the server, listens for and accepts incoming connections
     */
    void start_server();

    /**
     * @brief Generates a server hello message
     * @param client_nonce A nonce generated by the client
     * @param session_id An identifier for the session
     * @param eph_pub_key The ephemeral public key
     * @return A server hello message.Ã¬
     */
    Message generate_server_hello(std::string client_nonce, uint32_t session_id, std::vector<unsigned char> &eph_pub_key);

    /**
     * @brief Generates a session identifier
     * @return A session identifier
     */
    uint32_t generate_session();

    /**
     * @brief 
     * 
     * @param out_msg outgoing message
     * @param in_msg incoming message
     * @param sess 
     */
    void handle_login(Message &out_msg, Message &in_msg, Session *sess);

    /**
     * @brief 
     * 
     * @param out_msg outgoing message
     * @param in_msg incoming message
     * @param sess 
     */
    void handle_transfer(Message &out_msg, Message &in_msg, Session *sess);

    /**
     * @brief 
     * 
     * @param out_msg outgoing message
     * @param sess 
     */
    void handle_get_balance(Message &out_msg, Session *sess);

    /**
     * @brief 
     * @param out_msg outgoing message
     * @param sess 
     */
    void handle_get_transfer_history(Message &out_msg, Session *sess);

    /**
     * @brief 
     * @param new_socket The socket descriptor of the new connection
     * @param in_buff incoming buffer
     */
    void handle_handshake(int new_socket, std::vector<unsigned char> &in_buff);

    /**
     * @brief 
     * @param session_id 
     * @return Session*, null if the session does not exist
     */
    Session *get_session_by_id(uint32_t session_id);

    /**
     * @brief 
     * @param session_id 
     */
    void delete_session_by_id(uint32_t session_id);

    /**
     * @brief Checks if a message is valid using timestamps and HMAC
     * 
     * @param in_msg 
     * @param sess 
     * @return true 
     * @return false 
     */
    bool is_message_valid(Message &in_msg, Session *sess);

    /**
     * @brief Handles a client connection
     * @param new_socket The socket descriptor of the new connection
     */
    void handle_client_connection(int new_socket);

    /**
     * @brief Checks whether a user is logged in or not
     * @param sess user session
     * @return bool 
     */
    bool is_user_logged_in(Session *sess);

private:
    pthread_mutex_t sessions_mutex;
    std::unordered_map<uint32_t, Session> sessions;
    X509 *own_cert;
    int server_socket;
    std::vector<unsigned char> enc_key;
    std::vector<unsigned char> priv_key;
};

#endif // SERVER_H
